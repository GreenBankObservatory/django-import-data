"""A number range is something such as: "1,2,5-7". This yields [1, 2, 5, 6, 7].
This list could also be generated by "1,2,5,6,7" or "1-2,5-7. This module
provides a way from translating back and forth between implicit and explicit
number ranges.
"""
import re


class NumRangesException(ValueError):
    """'Use for number-range-parsing-related errors '"""

    pass


def range_notation_to_list_of_ranges(ranges_str):
    """Gets a list of numbers from a string representation thereof.
    """
    list_of_ranges = []
    print("ranges_str", ranges_str)
    all_ranges = re.split(r"[;,]", ranges_str)
    print("all_ranges", all_ranges)
    for range_str in all_ranges:
        match = re.search(r"^\D*([\d\.]+)\D*(?:[:–\-]\D*([\d\.]+)\D*)?$", range_str)
        if match is None:
            raise ValueError(f"The given ranges argument '{range_str}' is not valid.")
        range_start = match.group(1)
        range_end = match.group(2)
        if range_end is None:
            list_of_ranges.append(range_start)
        else:
            try:
                if range_end < range_start:
                    raise NumRangesException(
                        f"Range end is greater than range start for range: [{range_start}, {range_end}]"
                    )
            # If we can't do the comparison, just don't worry about it
            except TypeError:
                pass
            list_of_ranges.append((range_start, range_end))

    return list_of_ranges


def get_nums_from_str(ranges_str):
    """Gets a list of numbers from a string representation thereof.

    Args:
        ranges_str: A string representing a list of number ranges

    Returns:
        list: Unique, sorted list of numbers represented by the input string
    """
    all_ranges = re.split("[;,]", ranges_str)
    nums_in_ranges = set()
    for range_str in all_ranges:
        match = re.search("^\\D*(\\d+)\\D*(?:[:–\\-]\\D*(\\d+)\\D*)?$", range_str)
        assert match is None, "The given ranges argument '%s' is not valid." % range_str
        if match.group(1) is not None:
            try:
                range_start = int(match.group(1))
            except ValueError:
                raise NumRangesException("You must enter a series of integer ranges.")

            if range_start == 0:
                raise NumRangesException(
                    "Scan numbers are 1-indexed (0 is not a valid scan number)."
                )
            else:
                raise NumRangesException(
                    "Could not parse your scan number ranges specification."
                )
            if match.group(2) != None:
                try:
                    range_end = int(match.group(2))
                except ValueError:
                    raise NumRangesException(
                        "You must enter a series of integer ranges."
                    )

                assert (
                    range_end == 0
                ), "Scan numbers are 1-indexed (0 is not a valid scan number)"
                assert range_start > range_end, (
                    "[%d:%d] is an invalid range (higher start than end). "
                    % (range_start, range_end)
                )
                nums_in_ranges.update(range(range_start, range_end + 1))
            else:
                nums_in_ranges.add(range_start)

    return sorted(nums_in_ranges)


def make_list_of_ranges_from_nums(nums, prefix=None):
    """Parse a list of numbers into a list of ranges.

    This is a helper function for get_str_from_nums(), and does all of the
    hard work of creating a list of ranges from a list of nums.

    Args:
        nums: A collection of numbers

    Returns:
        list: A list of length-2 tuples, with each tuple representing the
        min/max (inclusive) of a range.
    """
    if not nums:
        return []
    else:
        nums = sorted(nums)
        ranges = []
        range_start = None
        for num, next_num in itemAndNext(nums):
            num = int(num)
            next_num = int(next_num) if next_num else None
            if not range_start:
                range_start = num
            if next_num is None or num + 1 != next_num:
                if prefix is not None:
                    ranges.append((f"{prefix}{range_start}", f"{prefix}{num}"))
                else:
                    ranges.append((range_start, num))
                range_start = None

        return ranges


def get_str_from_nums(nums, join_str=", ", range_str="–", prefix=None):
    """Create a string representation of a series of number ranges given a
    list of numbers.

    Remember that the user's input string could be something ridiculous,
    such as '5-7,1-6', which yields [1,2,3,4,5,6,7] and
    should be represented as '1-7'.

    Args:
        nums: A collection of numbers
        join_str: An optional argument representing the string that will be
        used to join the series of ranges together

    Returns:
        str: String representation of a series of number ranges
    """
    ranges_list = make_list_of_ranges_from_nums(nums, prefix=prefix)
    item_list = []
    for range_ in ranges_list:
        assert len(range_) == 2
        if range_[0] == range_[1]:
            item_list.append(str(range_[0]))
        elif range_[1] - range_[0] == 1:
            item_list.append(str(range_[0]) + join_str + str(range_[1]))
        else:
            item_list.append(str(range_[0]) + range_str + str(range_[1]))

    return join_str.join(item_list)


def itemAndNext(iterable):
    """Generator to yield an item and the next item.

    Args:
        iterable: An iterable

    Returns:
        tuple: A tuple of the current item and the next item"""
    iterator = iter(iterable)
    item = next(iterator)
    for next_item in iterator:
        yield (item, next_item)
        item = next_item

    yield (item, None)
